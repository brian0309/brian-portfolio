<script is:inline>
// --- TYPEWRITER EFFECT ---
const textElement = document.getElementById('typewriter');
const textToType = "Hi, I'm Brian Carlo.\nI build web applications and digital experiences.";
let index = 0;

function typeText() {
    if (textElement && index < textToType.length) {
        const char = textToType.charAt(index);
        textElement.innerHTML += char === '\n' ? '<br>' : char;
        index++;
        setTimeout(typeText, Math.random() * 100 + 50); // Random typing speed
    }
}

// Start typing after a short delay
setTimeout(typeText, 1000);

// --- MOBILE MENU LOGIC ---
const menuBtn = document.getElementById('menu-btn');
const mobileMenu = document.getElementById('mobile-menu');
const closeMenuBtn = document.getElementById('close-menu');
const menuLinks = document.querySelectorAll('.menu-link');

function openMenu() {
    if (mobileMenu) {
        mobileMenu.classList.remove('hidden');
        mobileMenu.classList.remove('tv-close');
        mobileMenu.classList.add('tv-open');
        mobileMenu.classList.add('flex');
    }
}

function closeMenu() {
    if (mobileMenu) {
        mobileMenu.classList.remove('tv-open');
        mobileMenu.classList.add('tv-close');
        // Wait for animation to finish before hiding
        setTimeout(() => {
            mobileMenu.classList.add('hidden');
            mobileMenu.classList.remove('flex');
        }, 300);
    }
}

if (menuBtn) menuBtn.addEventListener('click', openMenu);
if (closeMenuBtn) closeMenuBtn.addEventListener('click', closeMenu);

// Close menu when a link is clicked
menuLinks.forEach(link => {
    link.addEventListener('click', closeMenu);
});

// --- BUG GENERATION AND INTERACTION LOGIC ---
const bugContainer = document.getElementById('bug-container');
const winModal = document.getElementById('win-modal');
const closeWinModalBtn = document.getElementById('close-win-modal');

const MAX_BUGS = 15; // Maximum number of bugs on screen
const activeBugs = []; // Store bug objects for physics
let gameWon = false; // Track if player has won
let eliminatedCount = 0; // Track eliminated bugs

// Status display elements
const statusText = document.getElementById('status-text');
const bugCountEl = document.getElementById('bug-count');
const eliminatedCountEl = document.getElementById('eliminated-count');

// Update the status display
function updateStatus() {
    if (gameWon) {
        if (statusText) statusText.innerHTML = '<span class="text-cyber-green">SYSTEM STATUS: CLEANED AND OPERATIONAL</span>';
    } else {
        if (bugCountEl) bugCountEl.textContent = activeBugs.length;
        if (eliminatedCountEl) eliminatedCountEl.textContent = eliminatedCount;
    }
}

// Win Modal Logic
function showWinModal() {
    gameWon = true;
    updateStatus();
    if (winModal) winModal.classList.remove('hidden');
}

if (closeWinModalBtn) {
    closeWinModalBtn.addEventListener('click', () => {
        if (winModal) winModal.classList.add('hidden');
    });
}

// Function to create and position a single bug
function createBug() {
    // Don't spawn if game is won or max bugs reached
    if (gameWon || activeBugs.length >= MAX_BUGS) return;
    if (!bugContainer) return;

    const wrapper = document.createElement('div');
    wrapper.classList.add('bug-wrapper');

    const bug = document.createElement('div');
    bug.classList.add('code-bug');
    wrapper.appendChild(bug);

    // Random size between 20px and 50px
    const size = 20 + Math.random() * 30;

    // Set size on wrapper
    wrapper.style.width = `${size}px`;
    wrapper.style.height = `${size}px`;

    // Initial random position
    let x = Math.random() * (window.innerWidth - size);
    let y = Math.random() * (window.innerHeight - size);

    // Initial random velocity (slightly faster for smaller bugs, but capped)
    const baseSpeed = 0.4 + Math.random() * 0.6;
    const sizeMultiplier = 0.8 + (0.4 * (50 - size) / 30); // Range: 0.8 to 1.2
    const speed = baseSpeed * sizeMultiplier;
    const angle = Math.random() * Math.PI * 2;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    // Set initial position
    wrapper.style.left = `${x}px`;
    wrapper.style.top = `${y}px`;

    // Bug data object
    const bugData = {
        element: wrapper,
        sprite: bug,
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        width: size,
        height: size,
        isDead: false
    };

    activeBugs.push(bugData);

    // Click/Touch listener
    const clickHandler = (event) => {
        event.preventDefault();
        event.stopPropagation();
        // Get client coordinates for feedback
        const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
        const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);

        squashBug(bugData, clientX, clientY);
    };

    wrapper.addEventListener('click', clickHandler);
    wrapper.addEventListener('touchstart', clickHandler);

    bugContainer.appendChild(wrapper);
    
    // Update status when bug spawns
    updateStatus();
}

// Function to handle bug click/touch (squash)
function squashBug(bugData, x, y) {
    if (bugData.isDead) return;
    bugData.isDead = true;

    // Increment eliminated count
    eliminatedCount++;

    // Disable interactions
    bugData.element.style.pointerEvents = 'none';

    // Add pop animation to the sprite (inner element)
    bugData.sprite.classList.add('pop');

    // Show feedback text
    showFeedback(x, y);

    // Remove after animation
    bugData.sprite.addEventListener('animationend', () => {
        bugData.element.remove();
        // Remove from activeBugs array
        const index = activeBugs.indexOf(bugData);
        if (index > -1) {
            activeBugs.splice(index, 1);
        }

        // Update status display
        updateStatus();

        // Check win condition
        if (activeBugs.length === 0) {
            showWinModal();
        }
    }, { once: true });
}

// Physics Loop
function updateBugs() {
    // Identify obstacles (elements to bounce off)
    // We target major layout blocks. Adding specific classes to HTML would be better, 
    // but we can use existing structure: Header and Cards.
    const obstacleSelectors = [
        'header',
        '.border-2', // Covers Hero, Skills, Projects, Contact
    ];

    // Collect all obstacle rects for this frame
    const obstacles = [];
    obstacleSelectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(el => {
            // Filter out small elements (like buttons) if they share the class
            if (el.tagName === 'BUTTON' || el.tagName === 'A') return;
            // Filter out hidden elements
            if (el.offsetParent === null) return;
            obstacles.push(el.getBoundingClientRect());
        });
    });

    activeBugs.forEach(bug => {
        if (bug.isDead) return;

        // Update position
        bug.x += bug.vx;
        bug.y += bug.vy;

        // Screen Edge Bouncing
        if (bug.x <= 0) {
            bug.x = 0;
            bug.vx *= -1;
        } else if (bug.x + bug.width >= window.innerWidth) {
            bug.x = window.innerWidth - bug.width;
            bug.vx *= -1;
        }

        if (bug.y <= 0) {
            bug.y = 0;
            bug.vy *= -1;
        } else if (bug.y + bug.height >= window.innerHeight) {
            bug.y = window.innerHeight - bug.height;
            bug.vy *= -1;
        }

        // Obstacle Bouncing
        // Simple AABB Collision Response
        for (const rect of obstacles) {
            if (
                bug.x < rect.right &&
                bug.x + bug.width > rect.left &&
                bug.y < rect.bottom &&
                bug.y + bug.height > rect.top
            ) {
                // Determine overlap depth
                const overlapLeft = (bug.x + bug.width) - rect.left;
                const overlapRight = rect.right - bug.x;
                const overlapTop = (bug.y + bug.height) - rect.top;
                const overlapBottom = rect.bottom - bug.y;

                // Find smallest overlap to resolve collision
                const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                if (minOverlap === overlapLeft) {
                    bug.x = rect.left - bug.width;
                    bug.vx *= -1;
                } else if (minOverlap === overlapRight) {
                    bug.x = rect.right;
                    bug.vx *= -1;
                } else if (minOverlap === overlapTop) {
                    bug.y = rect.top - bug.height;
                    bug.vy *= -1;
                } else if (minOverlap === overlapBottom) {
                    bug.y = rect.bottom;
                    bug.vy *= -1;
                }
            }
        }

        // Apply Position
        bug.element.style.left = `${bug.x}px`;
        bug.element.style.top = `${bug.y}px`;

        // Calculate Rotation (Standard math: 0rad is Right)
        // SVG bug points UP (-90deg or -PI/2). 
        // So if moving Right (0rad), we need to rotate it +90deg (+PI/2) relative to its base state.
        const angle = Math.atan2(bug.vy, bug.vx) + (Math.PI / 2);
        bug.sprite.style.transform = `rotate(${angle}rad)`;
    });

    requestAnimationFrame(updateBugs);
}

// Function to show transient feedback text
function showFeedback(x, y) {
    const feedback = document.createElement('div');
    feedback.classList.add('feedback', 'font-bit', 'text-cyber-green', 'text-xs');
    feedback.textContent = 'bug eliminated';
    feedback.style.left = `${x}px`;
    feedback.style.top = `${y}px`;

    document.body.appendChild(feedback);

    // Remove feedback after animation (1s)
    setTimeout(() => {
        feedback.remove();
    }, 1000);
}

// Start the loop
requestAnimationFrame(updateBugs);

// Initial bug population (random 5-10 bugs)
const initialBugCount = 5 + Math.floor(Math.random() * 6); // 5 to 10
for (let i = 0; i < initialBugCount; i++) {
    createBug();
}

// Respawn Timer (Every 10 seconds) - only if game not won
setInterval(() => {
    if (!gameWon && activeBugs.length < MAX_BUGS) {
        createBug();
    }
}, 10000);
</script>
