<script is:inline>
// --- TYPEWRITER EFFECT ---
const textElement = document.getElementById('typewriter');
const textToType = "Hi, I'm Brian.";
let index = 0;

function typeText() {
    if (textElement && index < textToType.length) {
        const char = textToType.charAt(index);
        textElement.innerHTML += char === '\n' ? '<br>' : char;
        index++;
        setTimeout(typeText, Math.random() * 100 + 50); // Random typing speed
    }
}

// Start typing after a short delay
setTimeout(typeText, 1000);

// --- BUG GENERATION AND INTERACTION LOGIC ---
const bugContainer = document.getElementById('bug-container');
const bugStatus = document.getElementById('bug-status');
const footerBrian = document.getElementById('footer-brian');
const winModal = document.getElementById('win-modal');
const closeWinModalBtn = document.getElementById('close-win-modal');

const MAX_BUGS = 15; // Maximum number of bugs on screen
const activeBugs = []; // Store bug objects for physics
let gameWon = false; // Track if player has won
let eliminatedCount = 0; // Track eliminated bugs
let brianClicks = 0;
let gameInitialized = false;

// Status display elements
const statusText = document.getElementById('status-text');
const bugCountEl = document.getElementById('bug-count');
const eliminatedCountEl = document.getElementById('eliminated-count');
const projectInitTimerEl = document.getElementById('identity-init-timer');
let projectCountdownInterval = null;
let scrollListener = null;

// Update the status display
function updateStatus() {
    if (gameWon) {
        if (statusText) statusText.innerHTML = '<span class="text-cyber-green">SYSTEM STATUS: CLEANED AND OPERATIONAL</span>';
    } else {
        if (bugCountEl) bugCountEl.textContent = activeBugs.length;
        if (eliminatedCountEl) eliminatedCountEl.textContent = eliminatedCount;
    }
}

function stopProjectCountdown() {
    if (projectCountdownInterval) {
        clearInterval(projectCountdownInterval);
        projectCountdownInterval = null;
    }
}

function hideCloseButton() {
    if (closeWinModalBtn) {
        closeWinModalBtn.classList.add('hidden');
    }
}

function showCloseButton() {
    if (closeWinModalBtn) {
        closeWinModalBtn.classList.remove('hidden');
    }
}

function waitForScrollAndShowCloseButton() {
    if (!closeWinModalBtn) return;
    const revealButton = () => {
        if (window.scrollY > 0) {
            showCloseButton();
            if (scrollListener) {
                window.removeEventListener('scroll', scrollListener);
                scrollListener = null;
            }
        }
    };

    if (window.scrollY > 0) {
        showCloseButton();
        return;
    }

    scrollListener = () => {
        revealButton();
    };
    window.addEventListener('scroll', scrollListener);
}

function startProjectCountdown(duration = 3) {
    stopProjectCountdown();
    let countdown = duration;
    if (projectInitTimerEl) projectInitTimerEl.textContent = String(countdown);
    projectCountdownInterval = setInterval(() => {
        countdown -= 1;
        if (projectInitTimerEl) projectInitTimerEl.textContent = String(Math.max(countdown, 0));
        if (countdown <= 0) {
            stopProjectCountdown();
            const aboutSection = document.getElementById('about');
            if (aboutSection) {
                aboutSection.scrollIntoView({ behavior: 'smooth' });
            }
            window.location.hash = '#about';
            waitForScrollAndShowCloseButton();
        }
    }, 1000);
}

// Win Modal Logic
function showWinModal() {
    gameWon = true;
    updateStatus();
    if (winModal) {
        winModal.classList.remove('hidden');
        winModal.classList.remove('tv-close');
        winModal.classList.add('tv-open');
        winModal.classList.add('flex');
    }
    hideCloseButton();
    startProjectCountdown();
}

if (closeWinModalBtn) {
    closeWinModalBtn.addEventListener('click', () => {
        if (winModal) {
            winModal.classList.remove('tv-open');
            winModal.classList.add('tv-close');
            setTimeout(() => {
                winModal.classList.add('hidden');
                winModal.classList.remove('flex');
            }, 300);
        }
        stopProjectCountdown();
        hideCloseButton();
        if (scrollListener) {
            window.removeEventListener('scroll', scrollListener);
            scrollListener = null;
        }
    });
}

// Function to create and position a single bug
function createBug() {
    // Don't spawn if game is won or max bugs reached
    if (gameWon || activeBugs.length >= MAX_BUGS) return;
    if (!bugContainer) return;

    const wrapper = document.createElement('div');
    wrapper.classList.add('bug-wrapper');

    const bug = document.createElement('div');
    bug.classList.add('code-bug');
    wrapper.appendChild(bug);

    // Random size between 20px and 50px
    const size = 20 + Math.random() * 30;

    // Set size on wrapper
    wrapper.style.width = `${size}px`;
    wrapper.style.height = `${size}px`;

    // Initial random position
    let x = Math.random() * (window.innerWidth - size);
    let y = Math.random() * (window.innerHeight - size);

    // Initial random velocity (slightly faster for smaller bugs, but capped)
    const baseSpeed = 0.4 + Math.random() * 0.6;
    const sizeMultiplier = 0.8 + (0.4 * (50 - size) / 30); // Range: 0.8 to 1.2
    const speed = baseSpeed * sizeMultiplier;
    const angle = Math.random() * Math.PI * 2;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    // Set initial position
    wrapper.style.left = `${x}px`;
    wrapper.style.top = `${y}px`;

    // Bug data object
    const bugData = {
        element: wrapper,
        sprite: bug,
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        width: size,
        height: size,
        isDead: false
    };

    activeBugs.push(bugData);

    // Click/Touch listener
    const clickHandler = (event) => {
        event.preventDefault();
        event.stopPropagation();
        // Get client coordinates for feedback
        const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
        const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);

        squashBug(bugData, clientX, clientY);
    };

    wrapper.addEventListener('click', clickHandler);
    wrapper.addEventListener('touchstart', clickHandler);

    bugContainer.appendChild(wrapper);
    
    // Update status when bug spawns
    updateStatus();
}

// Function to handle bug click/touch (squash)
function squashBug(bugData, x, y) {
    if (bugData.isDead) return;
    bugData.isDead = true;

    // Increment eliminated count
    eliminatedCount++;

    // Disable interactions
    bugData.element.style.pointerEvents = 'none';

    // Add pop animation to the sprite (inner element)
    bugData.sprite.classList.add('pop');

    // Show feedback text
    showFeedback(x, y);

    // Remove after animation
    bugData.sprite.addEventListener('animationend', () => {
        bugData.element.remove();
        // Remove from activeBugs array
        const index = activeBugs.indexOf(bugData);
        if (index > -1) {
            activeBugs.splice(index, 1);
        }

        // Update status display
        updateStatus();

        // Check win condition
        if (activeBugs.length === 0) {
            showWinModal();
        }
    }, { once: true });
}

// Physics Loop
function updateBugs() {
    // Identify obstacles (elements to bounce off)
    // We target major layout blocks. Adding specific classes to HTML would be better, 
    // but we can use existing structure: Header and Cards.
    const obstacleSelectors = [
        'header',
        '.border-2', // Covers Hero, Skills, Projects, Contact
    ];

    // Collect all obstacle rects for this frame
    const obstacles = [];
    obstacleSelectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(el => {
            // Filter out small elements (like buttons) if they share the class
            if (el.tagName === 'BUTTON' || el.tagName === 'A') return;
            // Filter out hidden elements
            if (el.offsetParent === null) return;
            obstacles.push(el.getBoundingClientRect());
        });
    });

    activeBugs.forEach(bug => {
        if (bug.isDead) return;

        // Update position
        bug.x += bug.vx;
        bug.y += bug.vy;

        // Screen Edge Bouncing
        if (bug.x <= 0) {
            bug.x = 0;
            bug.vx *= -1;
        } else if (bug.x + bug.width >= window.innerWidth) {
            bug.x = window.innerWidth - bug.width;
            bug.vx *= -1;
        }

        if (bug.y <= 0) {
            bug.y = 0;
            bug.vy *= -1;
        } else if (bug.y + bug.height >= window.innerHeight) {
            bug.y = window.innerHeight - bug.height;
            bug.vy *= -1;
        }

        // Obstacle Bouncing
        // Simple AABB Collision Response
        for (const rect of obstacles) {
            if (
                bug.x < rect.right &&
                bug.x + bug.width > rect.left &&
                bug.y < rect.bottom &&
                bug.y + bug.height > rect.top
            ) {
                // Determine overlap depth
                const overlapLeft = (bug.x + bug.width) - rect.left;
                const overlapRight = rect.right - bug.x;
                const overlapTop = (bug.y + bug.height) - rect.top;
                const overlapBottom = rect.bottom - bug.y;

                // Find smallest overlap to resolve collision
                const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                if (minOverlap === overlapLeft) {
                    bug.x = rect.left - bug.width;
                    bug.vx *= -1;
                } else if (minOverlap === overlapRight) {
                    bug.x = rect.right;
                    bug.vx *= -1;
                } else if (minOverlap === overlapTop) {
                    bug.y = rect.top - bug.height;
                    bug.vy *= -1;
                } else if (minOverlap === overlapBottom) {
                    bug.y = rect.bottom;
                    bug.vy *= -1;
                }
            }
        }

        // Apply Position
        bug.element.style.left = `${bug.x}px`;
        bug.element.style.top = `${bug.y}px`;

        // Calculate Rotation (Standard math: 0rad is Right)
        // SVG bug points UP (-90deg or -PI/2). 
        // So if moving Right (0rad), we need to rotate it +90deg (+PI/2) relative to its base state.
        const angle = Math.atan2(bug.vy, bug.vx) + (Math.PI / 2);
        bug.sprite.style.transform = `rotate(${angle}rad)`;
    });

    requestAnimationFrame(updateBugs);
}

// Function to show transient feedback text
function showFeedback(x, y) {
    const feedback = document.createElement('div');
    feedback.classList.add('feedback', 'font-bit', 'text-cyber-green', 'text-xs');
    feedback.textContent = 'bug eliminated';
    feedback.style.left = `${x}px`;
    feedback.style.top = `${y}px`;

    document.body.appendChild(feedback);

    // Remove feedback after animation (1s)
    setTimeout(() => {
        feedback.remove();
    }, 1000);
}

// Start the loop
requestAnimationFrame(updateBugs);

// Easter Egg Logic: Initialize game after 3 clicks on "BRIAN" in footer
function initBugGame() {
    if (gameInitialized) return;
    gameInitialized = true;

    if (bugContainer) bugContainer.classList.remove('hidden');
    if (bugStatus) bugStatus.classList.remove('hidden');

    // Initial bug population (random 5-10 bugs)
    const initialBugCount = 5 + Math.floor(Math.random() * 6); // 5 to 10
    for (let i = 0; i < initialBugCount; i++) {
        createBug();
    }

    // Respawn Timer (Every 10 seconds) - only if game not won
    setInterval(() => {
        if (!gameWon && activeBugs.length < MAX_BUGS) {
            createBug();
        }
    }, 10000);
}

if (footerBrian) {
    footerBrian.addEventListener('click', () => {
        brianClicks++;
        if (brianClicks >= 3) {
            initBugGame();
            // Optional: visual feedback that it's activated
            footerBrian.classList.remove('text-cyber-pink');
            footerBrian.classList.add('text-cyber-green');
            setTimeout(() => {
                footerBrian.classList.remove('text-cyber-green');
                footerBrian.classList.add('text-cyber-pink');
            }, 1000);
        }
    });
}
</script>
